"use client";

import { useState, useEffect } from "react";
import "./push-notifications.css";
import { useUser } from "@/modules/auth/hooks/use-user";

export function PushNotificationManager() {
  const [permission, setPermission] =
    useState<NotificationPermission>("default");
  const [isSubscribed, setIsSubscribed] = useState(false);
  const [showPermissionPrompt, setShowPermissionPrompt] = useState(false);
  const [isRefreshing, setIsRefreshing] = useState(false);
  const { user } = useUser();

  useEffect(() => {
    const isMobile =
      /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
        navigator.userAgent
      );

    // Check current permission status
    if ("Notification" in window) {
      setPermission(Notification.permission);
      if (process.env.NODE_ENV === "development") {
        console.log("üîî Notification permission:", Notification.permission);
        console.log("üì± Is mobile device:", isMobile);
      }
    }

    // Check if service worker is registered and user is subscribed
    checkSubscriptionStatus();

    // Mobile-first automatic permission strategy
    if (isMobile && Notification.permission === "default") {
      // Auto-request permission on mobile immediately after user interaction
      const handleFirstUserInteraction = () => {
        autoRequestMobilePermissions();
        // Remove event listeners after first use
        document.removeEventListener("click", handleFirstUserInteraction);
        document.removeEventListener("touch", handleFirstUserInteraction);
        document.removeEventListener("scroll", handleFirstUserInteraction);
      };

      // Wait for any user interaction, then request permissions
      document.addEventListener("click", handleFirstUserInteraction, {
        once: true,
      });
      document.addEventListener("touchstart", handleFirstUserInteraction, {
        once: true,
      });
      document.addEventListener("scroll", handleFirstUserInteraction, {
        once: true,
      });

      // Fallback: auto-request after 3 seconds if no interaction
      setTimeout(() => {
        if (Notification.permission === "default") {
          autoRequestMobilePermissions();
        }
      }, 3000);
    } else {
      // Check if we should show permission prompt for desktop
      const shouldShowPrompt = checkIfShouldShowPrompt();
      if (shouldShowPrompt) {
        setTimeout(() => {
          setShowPermissionPrompt(true);
        }, 1000);
      }
    }
  }, []);

  const checkIfShouldShowPrompt = () => {
    if (!("Notification" in window)) return false;

    // If already granted or denied, don't show
    if (Notification.permission !== "default") return false;

    // Check if user dismissed it recently
    const dismissedAt = localStorage.getItem("push-notification-dismissed");
    if (dismissedAt) {
      const dismissedTime = parseInt(dismissedAt);
      const now = Date.now();
      const daysSinceDismissed = (now - dismissedTime) / (1000 * 60 * 60 * 24);

      // Show again after 7 days
      if (daysSinceDismissed < 7) {
        return false;
      }
    }

    return true;
  };

  const checkSubscriptionStatus = async () => {
    if ("serviceWorker" in navigator && "PushManager" in window) {
      try {
        // Check if new service worker is already registered
        let registration = await navigator.serviceWorker.getRegistration();

        // Only register if not already registered with the correct file
        if (
          !registration ||
          !registration.active?.scriptURL.includes("sw-new.js")
        ) {
          if (process.env.NODE_ENV === "development") {
            console.log("üîÑ Registering new service worker...");
          }

          // Unregister old service worker first if exists
          if (
            registration &&
            !registration.active?.scriptURL.includes("sw-new.js")
          ) {
            await registration.unregister();
            if (process.env.NODE_ENV === "development") {
              console.log("üóëÔ∏è Old service worker unregistered");
            }
          }

          registration = await navigator.serviceWorker.register("/sw-new.js", {
            scope: "/",
          });

          if (process.env.NODE_ENV === "development") {
            console.log("‚úÖ New service worker registered:", registration);
          }
        }

        // Wait for service worker to be ready
        const readyRegistration = await navigator.serviceWorker.ready;
        if (process.env.NODE_ENV === "development") {
          console.log("‚úÖ SW Ready:", readyRegistration.active?.scriptURL);
        }

        const subscription =
          await readyRegistration.pushManager.getSubscription();
        if (process.env.NODE_ENV === "development") {
          console.log("üì® Current push subscription:", !!subscription);
        }

        setIsSubscribed(!!subscription);

        // Only hide permission prompt if user is already subscribed
        if (subscription) {
          setShowPermissionPrompt(false);
        }
      } catch (error) {
        if (process.env.NODE_ENV === "development") {
          console.error("‚ùå Error checking subscription status:", error);
        }
      }
    }
  };

  const autoRequestMobilePermissions = async () => {
    if (!("Notification" in window) || !("serviceWorker" in navigator)) {
      return false;
    }

    try {
      if (process.env.NODE_ENV === "development") {
        console.log("üì± Auto-requesting mobile push permissions...");
      }

      // Direct permission request without user confirmation on mobile
      const permission = await Notification.requestPermission();
      setPermission(permission);

      if (permission === "granted") {
        if (process.env.NODE_ENV === "development") {
          console.log("‚úÖ Mobile permissions granted, subscribing...");
        }
        await subscribeUserToPush();
        return true;
      } else {
        if (process.env.NODE_ENV === "development") {
          console.log("‚ùå Mobile permissions denied:", permission);
        }
      }
    } catch (error) {
      if (process.env.NODE_ENV === "development") {
        console.error("‚ùå Mobile permission request failed:", error);
      }
    }

    return false;
  };

  const requestPermission = async () => {
    if (!("Notification" in window)) {
      console.error("This browser does not support notifications");
      alert("·Éó·É•·Éï·Éî·Éú·Éò ·Éë·É†·Éê·É£·Éñ·Éî·É†·Éò ·Éê·É† ·Éõ·ÉÆ·Éê·É†·É° ·É£·É≠·Éî·É†·É° ·É®·Éî·É¢·Éß·Éù·Éë·Éò·Éú·Éî·Éë·Éî·Éë·É°");
      return false;
    }

    if (!("serviceWorker" in navigator)) {
      console.error("Service workers are not supported");
      alert(
        "·Éó·É•·Éï·Éî·Éú·Éò ·Éë·É†·Éê·É£·Éñ·Éî·É†·Éò ·Éê·É† ·Éõ·ÉÆ·Éê·É†·É° ·É£·É≠·Éî·É†·É° service workers-·É°, ·É†·Éù·Éõ·Éö·Éî·Éë·Éò·É™ ·É°·Éê·É≠·Éò·É†·Éù·Éê push ·É®·Éî·É¢·Éß·Éù·Éë·Éò·Éú·Éî·Éë·Éî·Éë·Éò·É°·Éó·Éï·Éò·É°"
      );
      return false;
    }

    try {
      // Check if we're in Edge and handle it differently
      const isEdge = navigator.userAgent.indexOf("Edg") > -1;

      if (process.env.NODE_ENV === "development") {
        console.log("üîç Browser detection - Edge:", isEdge);
        console.log("üîç Current permission:", Notification.permission);
      }

      // For Edge, try a more direct approach
      if (isEdge && Notification.permission === "default") {
        // Show a more explicit message for Edge users
        const userConfirmed = confirm(
          "·Éó·É•·Éï·Éî·Éú ·Éò·Éß·Éî·Éú·Éî·Éë·Éó Microsoft Edge-·É°. ·É®·Éî·É¢·Éß·Éù·Éë·Éò·Éú·Éî·Éë·Éî·Éë·Éò·É° ·Éõ·Éò·É°·Éê·É¶·Éî·Éë·Éê·Éì ·Éì·Éê·Éê·É≠·Éò·É†·Éî·Éó 'OK' ·Éì·Éê ·É®·Éî·Éõ·Éì·Éî·Éí 'Allow' ·É¶·Éò·Éö·Éê·Éô·É° popup-·É®·Éò."
        );

        if (!userConfirmed) {
          return false;
        }
      }

      const permission = await Notification.requestPermission();

      if (process.env.NODE_ENV === "development") {
        console.log("üîî Permission result:", permission);
      }

      setPermission(permission);

      if (permission === "granted") {
        await subscribeUserToPush();
        return true;
      } else if (permission === "denied") {
        const message = isEdge
          ? "·É®·Éî·É¢·Éß·Éù·Éë·Éò·Éú·Éî·Éë·Éî·Éë·Éò ·Éì·Éê·Éë·Éö·Éù·Éô·Éò·Éö·Éò·Éê Edge-·É®·Éò. ·Éí·Éê·ÉÆ·É°·Éî·Éú·Éò·Éó Edge Settings > Cookies and site permissions > Notifications ·Éì·Éê ·Éì·Éê·É£·É®·Éï·Éò·Éó localhost-·Éò·É°·Éó·Éï·Éò·É°"
          : "·É®·Éî·É¢·Éß·Éù·Éë·Éò·Éú·Éî·Éë·Éî·Éë·Éò ·Éì·Éê·Éë·Éö·Éù·Éô·Éò·Éö·Éò·Éê. ·Éí·Éó·ÉÆ·Éù·Éï·Éó, ·É©·Éê·É†·Éó·Éù·Éó ·É®·Éî·É¢·Éß·Éù·Éë·Éò·Éú·Éî·Éë·Éî·Éë·Éò ·Éë·É†·Éê·É£·Éñ·Éî·É†·Éò·É° ·Éû·Éê·É†·Éê·Éõ·Éî·É¢·É†·Éî·Éë·É®·Éò";
        alert(message);
      } else if (permission === "default") {
        alert("·Éí·Éó·ÉÆ·Éù·Éï·Éó, ·Éí·Éê·Éõ·Éù·Éò·Éß·Éî·Éú·Éù·Éó ·Éõ·Éî·Éù·É†·Éî ·É¶·Éò·Éö·Éê·Éô·Éò notification-·Éî·Éë·Éò·É° ·É©·Éê·É°·Éê·É†·Éó·Éê·Éï·Éê·Éì");
      }

      return false;
    } catch (error) {
      console.error("Error requesting notification permission:", error);
      alert("·É®·Éî·É™·Éì·Éù·Éõ·Éê ·É®·Éî·É¢·Éß·Éù·Éë·Éò·Éú·Éî·Éë·Éî·Éë·Éò·É° ·Éú·Éî·Éë·Éê·É†·Éó·Éï·Éò·É° ·Éõ·Éù·Éó·ÉÆ·Éù·Éï·Éú·Éò·É°·Éê·É°");
      return false;
    }
  };

  const subscribeUserToPush = async () => {
    try {
      if (process.env.NODE_ENV === "development") {
        console.log("üîÑ Starting push subscription process...");
      }

      // Check if service worker is available
      if (!("serviceWorker" in navigator)) {
        throw new Error("Service Worker not supported");
      }

      // Check if service worker is already registered, if not register it
      let registration = await navigator.serviceWorker.getRegistration();
      if (!registration) {
        if (process.env.NODE_ENV === "development") {
          console.log("üìù Service worker not registered, registering...");
        }
        registration = await navigator.serviceWorker.register("/sw-new.js", {
          scope: "/",
        });
        if (process.env.NODE_ENV === "development") {
          console.log("‚úÖ Service worker registered:", registration);
        }
      }

      if (process.env.NODE_ENV === "development") {
        console.log("üìã Waiting for service worker to be ready...");
      }
      const readyRegistration = await navigator.serviceWorker.ready;
      if (process.env.NODE_ENV === "development") {
        console.log("‚úÖ Service worker ready:", readyRegistration);
      }

      // Generate VAPID key (you'll need to replace this with your actual VAPID public key)
      const vapidPublicKey =
        process.env.NEXT_PUBLIC_VAPID_PUBLIC_KEY ||
        "BMxYbPxp5WvZrF_2XQ4K7BzXu8TeYK5lDrFcH0Prf8J0FFJCNThE-MUHcJ3RnJSDtHzYN4RHjYx1fJyy4kJp0n8";

      if (process.env.NODE_ENV === "development") {
        console.log(
          "üîë Using VAPID key:",
          vapidPublicKey.substring(0, 20) + "..."
        );
      }

      const subscription = await readyRegistration.pushManager.subscribe({
        userVisibleOnly: true,
        applicationServerKey: urlBase64ToUint8Array(vapidPublicKey),
      });

      if (process.env.NODE_ENV === "development") {
        console.log("üì® Push subscription created:", subscription);
      }

      // Send subscription to the Nest.js backend
      const apiUrl = `${process.env.NEXT_PUBLIC_API_URL}/push/subscribe`;
      if (process.env.NODE_ENV === "development") {
        console.log("üåê Sending to API:", apiUrl);
      }

      const response = await fetch(apiUrl, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          subscription,
          userId: user?._id,
          userEmail: user?.email,
        }),
      });

      if (process.env.NODE_ENV === "development") {
        console.log("üì° API response status:", response.status);
      }

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(
          `HTTP error! status: ${response.status}, message: ${errorText}`
        );
      }

      const result = await response.json();
      if (process.env.NODE_ENV === "development") {
        console.log("‚úÖ Subscription successful:", result);
      }

      setIsSubscribed(true);
      setShowPermissionPrompt(false);

      alert("‚úÖ ·É¨·Éê·É†·Éõ·Éê·É¢·Éî·Éë·Éò·Éó ·Éí·Éê·Éõ·Éù·Éò·É¨·Éî·É†·Éî·Éó ·É®·Éî·É¢·Éß·Éù·Éë·Éò·Éú·Éî·Éë·Éî·Éë·Éò!");
    } catch (error) {
      if (process.env.NODE_ENV === "development") {
        console.error("‚ùå Failed to subscribe user:", error);
      }
      alert(
        `‚ùå ·É®·Éî·É™·Éì·Éù·Éõ·Éê ·Éí·Éê·Éõ·Éù·É¨·Éî·É†·Éò·É°·Éê·É°: ${
          error instanceof Error ? error.message : String(error)
        }`
      );
    }
  };

  const unsubscribe = async () => {
    try {
      // Ensure service worker is registered
      let registration = await navigator.serviceWorker.getRegistration();
      if (!registration) {
        registration = await navigator.serviceWorker.register("/sw.js", {
          scope: "/",
        });
      }

      const readyRegistration = await navigator.serviceWorker.ready;
      const subscription =
        await readyRegistration.pushManager.getSubscription();

      if (subscription) {
        await subscription.unsubscribe();

        // Notify server to remove subscription
        await fetch("/api/push/unsubscribe", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({ endpoint: subscription.endpoint }),
        });

        setIsSubscribed(false);
        if (process.env.NODE_ENV === "development") {
          console.log("User unsubscribed from push notifications");
        }
      }
    } catch (error) {
      console.error("Failed to unsubscribe user:", error);
    }
  };

  const handleDismiss = () => {
    setShowPermissionPrompt(false);
    localStorage.setItem("push-notification-dismissed", Date.now().toString());
  };

  const testPushNotification = async () => {
    if (process.env.NODE_ENV === "development") {
      console.log("üß™ Testing push notification...");

      // Check service worker
      if ("serviceWorker" in navigator) {
        const registration = await navigator.serviceWorker.getRegistration();
        console.log("üîç SW Registration:", registration);

        if (registration) {
          const subscription = await registration.pushManager.getSubscription();
          console.log("üì® Push Subscription:", subscription);

          if (subscription) {
            console.log("üì® Endpoint:", subscription.endpoint);

            // Test notification locally
            const testNotification = new Notification("Test Notification", {
              body: "This is a test push notification",
              icon: "/android-icon-192x192.png",
              tag: "test-notification",
            });

            setTimeout(() => testNotification.close(), 3000);
          } else {
            console.log("‚ùå No push subscription found");
          }
        } else {
          console.log("‚ùå No service worker registration found");
        }
      } else {
        console.log("‚ùå Service Worker not supported");
      }
    }
  };

  const refreshCache = async () => {
    if (!("serviceWorker" in navigator)) return;

    setIsRefreshing(true);
    try {
      // Clear all caches
      const cacheNames = await caches.keys();
      await Promise.all(
        cacheNames.map((cacheName) => caches.delete(cacheName))
      );

      // Force refresh the page
      window.location.reload();
    } catch (error) {
      console.error("Error clearing cache:", error);
      setIsRefreshing(false);
    }
  };

  if (!showPermissionPrompt || permission === "granted" || isSubscribed) {
    return null; // Don't show anything when subscribed or permission granted
  }

  return (
    <>
      <div className="push-notification-prompt">
        <div className="push-prompt-content">
          <div className="push-icon">
            <div className="bell-icon">üîî</div>
          </div>

          <div className="push-text">
            <h3>·Éõ·Éò·Éò·É¶·Éî·Éó ·É®·Éî·É¢·Éß·Éù·Éë·Éò·Éú·Éî·Éë·Éî·Éë·Éò</h3>
            <p>
              ·Éõ·Éù·Éò·É¶·Éî·Éó ·É®·Éî·É¢·Éß·Éù·Éë·Éò·Éú·Éî·Éë·Éî·Éë·Éò ·Éê·ÉÆ·Éê·Éö·Éò ·Éû·É†·Éù·Éì·É£·É•·É¢·Éî·Éë·Éò·É°, ·É§·Éê·É°·Éì·Éê·Éô·Éö·Éî·Éë·Éî·Éë·Éò·É°·Éê ·Éì·Éê ·É®·Éî·Éô·Éï·Éî·Éó·Éò·É°
              ·É°·É¢·Éê·É¢·É£·É°·Éò·É° ·É®·Éî·É°·Éê·ÉÆ·Éî·Éë
            </p>

            <div className="notification-types">
              <div className="notification-type">
                <span className="type-icon">üé®</span>
                <span>·Éê·ÉÆ·Éê·Éö·Éò ·ÉÆ·Éî·Éö·Éú·Éê·Éô·Éî·Éó·Éò ·Éû·É†·Éù·Éì·É£·É•·É¢·Éî·Éë·Éò</span>
              </div>
              <div className="notification-type">
                <span className="type-icon">üí∞</span>
                <span>·É§·Éê·É°·Éì·Éê·Éô·Éö·Éî·Éë·Éî·Éë·Éò ·Éì·Éê ·Éê·É•·É™·Éò·Éî·Éë·Éò</span>
              </div>
              <div className="notification-type">
                <span className="type-icon">üì¶</span>
                <span>·É®·Éî·Éô·Éï·Éî·Éó·Éò·É° ·Éõ·Éò·É¨·Éù·Éì·Éî·Éë·Éò·É° ·É°·É¢·Éê·É¢·É£·É°·Éò</span>
              </div>
            </div>
          </div>

          <div className="push-actions">
            <button className="push-allow-btn" onClick={requestPermission}>
              ·Éú·Éî·Éë·Éò·É° ·Éì·Éê·É†·Éó·Éï·Éê
            </button>
            <button
              className="push-refresh-btn"
              onClick={refreshCache}
              disabled={isRefreshing}
              title="·Éê·ÉÆ·Éê·Éö·Éò ·Éõ·Éù·Éú·Éê·É™·Éî·Éõ·Éî·Éë·Éò·É° ·É°·Éò·Éú·É•·É†·Éù·Éú·Éò·Éñ·Éê·É™·Éò·Éê"
            >
              {isRefreshing ? "üîÑ" : "üîÑ"} ·Éí·Éê·Éú·Éê·ÉÆ·Éö·Éî·Éë·Éê
            </button>
            {process.env.NODE_ENV === "development" && (
              <button
                className="push-test-btn"
                onClick={testPushNotification}
                title="·É¢·Éî·É°·É¢·Éò push notification"
              >
                üß™ ·É¢·Éî·É°·É¢·Éò
              </button>
            )}
            <button className="push-dismiss-btn" onClick={handleDismiss}>
              ·Éì·Éê·ÉÆ·É£·É†·Éï·Éê
            </button>
          </div>
        </div>
      </div>
    </>
  );
}

// Helper function to convert VAPID key
function urlBase64ToUint8Array(base64String: string) {
  const padding = "=".repeat((4 - (base64String.length % 4)) % 4);
  const base64 = (base64String + padding).replace(/-/g, "+").replace(/_/g, "/");

  const rawData = window.atob(base64);
  const outputArray = new Uint8Array(rawData.length);

  for (let i = 0; i < rawData.length; ++i) {
    outputArray[i] = rawData.charCodeAt(i);
  }
  return outputArray;
}
